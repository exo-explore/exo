# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import collections.abc

class ConnectionId:
    r"""
    TODO: documentation...
    """
    @staticmethod
    def new_unchecked(id:builtins.int) -> ConnectionId:
        r"""
        TODO: documentation
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

class ConnectionUpdate:
    @property
    def peer_id(self) -> PeerId:
        r"""
        Identity of the peer that we have connected to.
        """
    @property
    def connection_id(self) -> ConnectionId:
        r"""
        Identifier of the connection.
        """
    @property
    def local_addr(self) -> Multiaddr:
        r"""
        Local connection address.
        """
    @property
    def send_back_addr(self) -> Multiaddr:
        r"""
        Address used to send back data to the remote.
        """

class DiscoveryService:
    def __new__(cls, identity:Keypair) -> DiscoveryService: ...
    def add_connected_callback(self, callback:collections.abc.Callable[[ConnectionUpdate], None]) -> None: ...
    def add_disconnected_callback(self, callback:collections.abc.Callable[[ConnectionUpdate], None]) -> None: ...

class Keypair:
    r"""
    TODO: documentation...
    """
    @staticmethod
    def generate_ed25519() -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def generate_ecdsa() -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def generate_secp256k1() -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def from_protobuf_encoding(bytes:bytes) -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def rsa_from_pkcs8(bytes:bytes) -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def secp256k1_from_der(bytes:bytes) -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def ed25519_from_bytes(bytes:bytes) -> Keypair:
        r"""
        TODO: documentation
        """
    @staticmethod
    def ecdsa_from_bytes(bytes:bytes) -> Keypair:
        r"""
        TODO: documentation
        """
    def to_protobuf_encoding(self) -> bytes:
        r"""
        TODO: documentation
        """
    def to_peer_id(self) -> PeerId:
        r"""
        TODO: documentation
        """

class Multiaddr:
    r"""
    TODO: documentation...
    """
    @staticmethod
    def empty() -> Multiaddr:
        r"""
        TODO: documentation
        """
    @staticmethod
    def with_capacity(n:builtins.int) -> Multiaddr:
        r"""
        TODO: documentation
        """
    @staticmethod
    def from_bytes(bytes:bytes) -> Multiaddr:
        r"""
        TODO: documentation
        """
    @staticmethod
    def from_string(string:builtins.str) -> Multiaddr:
        r"""
        TODO: documentation
        """
    def len(self) -> builtins.int:
        r"""
        TODO: documentation
        """
    def is_empty(self) -> builtins.bool:
        r"""
        TODO: documentation
        """
    def to_bytes(self) -> bytes:
        r"""
        TODO: documentation
        """
    def to_string(self) -> builtins.str:
        r"""
        TODO: documentation
        """

class PeerId:
    r"""
    TODO: documentation...
    """
    @staticmethod
    def random() -> PeerId:
        r"""
        TODO: documentation
        """
    @staticmethod
    def from_bytes(bytes:bytes) -> PeerId:
        r"""
        TODO: documentation
        """
    def to_bytes(self) -> bytes:
        r"""
        TODO: documentation
        """
    def to_base58(self) -> builtins.str:
        r"""
        TODO: documentation
        """
    def __repr__(self) -> builtins.str:
        r"""
        TODO: documentation
        """
    def __str__(self) -> builtins.str:
        r"""
        TODO: documentation
        """

