# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class AllQueuesFullError(builtins.Exception):
    def __new__(cls, *args: typing.Any) -> AllQueuesFullError: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class Keypair:
    r"""
    Identity keypair of a node.
    """
    @staticmethod
    def generate() -> Keypair:
        r"""
        Generate a new Ed25519 keypair.
        """
    @staticmethod
    def from_bytes(bytes: bytes) -> Keypair:
        r"""
        Construct an Ed25519 keypair from secret key bytes
        """
    def to_bytes(self) -> bytes:
        r"""
        Get the secret key bytes underlying the keypair
        """
    def to_node_id(self) -> builtins.str:
        r"""
        Convert the `Keypair` into the corresponding `PeerId` string, which we use as our `NodeId`.
        """

@typing.final
class MessageTooLargeError(builtins.Exception):
    def __new__(cls, *args: typing.Any) -> MessageTooLargeError: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class NetworkingHandle:
    def __new__(cls, identity: Keypair) -> NetworkingHandle: ...
    async def gossipsub_subscribe(self, topic: builtins.str) -> builtins.bool:
        r"""
        Subscribe to a `GossipSub` topic.
        
        Returns `True` if the subscription worked. Returns `False` if we were already subscribed.
        """
    async def gossipsub_unsubscribe(self, topic: builtins.str) -> builtins.bool:
        r"""
        Unsubscribes from a `GossipSub` topic.
        
        Returns `True` if we were subscribed to this topic. Returns `False` if we were not subscribed.
        """
    async def gossipsub_publish(self, topic: builtins.str, data: bytes) -> None:
        r"""
        Publishes a message with multiple topics to the `GossipSub` network.
        
        If no peers are found that subscribe to this topic, throws `NoPeersSubscribedToTopicError` exception.
        """
    async def recv(self) -> PyFromSwarm: ...

@typing.final
class NoPeersSubscribedToTopicError(builtins.Exception):
    def __new__(cls, *args: typing.Any) -> NoPeersSubscribedToTopicError: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

class PyFromSwarm:
    @typing.final
    class Connection(PyFromSwarm):
        __match_args__ = ("peer_id", "connected",)
        @property
        def peer_id(self) -> builtins.str: ...
        @property
        def connected(self) -> builtins.bool: ...
        def __new__(cls, peer_id: builtins.str, connected: builtins.bool) -> PyFromSwarm.Connection: ...
    
    @typing.final
    class Message(PyFromSwarm):
        __match_args__ = ("origin", "topic", "data",)
        @property
        def origin(self) -> builtins.str: ...
        @property
        def topic(self) -> builtins.str: ...
        @property
        def data(self) -> bytes: ...
        def __new__(cls, origin: builtins.str, topic: builtins.str, data: bytes) -> PyFromSwarm.Message: ...
    
    ...

