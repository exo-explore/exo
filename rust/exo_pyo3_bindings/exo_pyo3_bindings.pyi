# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import enum
import typing

@typing.final
class AllQueuesFullError(builtins.Exception):
    def __new__(cls, *args: typing.Any) -> AllQueuesFullError: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class ConnectionUpdate:
    @property
    def update_type(self) -> ConnectionUpdateType:
        r"""
        Whether this is a connection or disconnection event
        """
    @property
    def peer_id(self) -> builtins.str:
        r"""
        Identity of the peer that we have connected to or disconnected from.
        """
    @property
    def remote_ipv4(self) -> builtins.str:
        r"""
        Remote connection's IPv4 address.
        """
    @property
    def remote_tcp_port(self) -> builtins.int:
        r"""
        Remote connection's TCP port.
        """

@typing.final
class Keypair:
    r"""
    Identity keypair of a node.
    """
    @staticmethod
    def generate() -> Keypair:
        r"""
        Generate a new Ed25519 keypair.
        """
    @staticmethod
    def from_bytes(bytes: bytes) -> Keypair:
        r"""
        Construct an Ed25519 keypair from secret key bytes
        """
    def to_bytes(self) -> bytes:
        r"""
        Get the secret key bytes underlying the keypair
        """
    def to_node_id(self) -> builtins.str:
        r"""
        Convert the `Keypair` into the corresponding `PeerId` string, which we use as our `NodeId`.
        """

@typing.final
class NetworkingHandle:
    def __new__(cls, identity: Keypair) -> NetworkingHandle: ...
    async def connection_update_recv(self) -> ConnectionUpdate:
        r"""
        Receives the next `ConnectionUpdate` from networking.
        """
    async def connection_update_recv_many(self, limit: builtins.int) -> builtins.list[ConnectionUpdate]:
        r"""
        Receives at most `limit` `ConnectionUpdate`s from networking and returns them.
        
        For `limit = 0`, an empty collection of `ConnectionUpdate`s will be returned immediately.
        For `limit > 0`, if there are no `ConnectionUpdate`s in the channel's queue this method
        will sleep until a `ConnectionUpdate`s is sent.
        """
    async def gossipsub_subscribe(self, topic: builtins.str) -> builtins.bool:
        r"""
        Subscribe to a `GossipSub` topic.
        
        Returns `True` if the subscription worked. Returns `False` if we were already subscribed.
        """
    async def gossipsub_unsubscribe(self, topic: builtins.str) -> builtins.bool:
        r"""
        Unsubscribes from a `GossipSub` topic.
        
        Returns `True` if we were subscribed to this topic. Returns `False` if we were not subscribed.
        """
    async def gossipsub_publish(self, topic: builtins.str, data: bytes) -> None:
        r"""
        Publishes a message with multiple topics to the `GossipSub` network.
        
        If no peers are found that subscribe to this topic, throws `NoPeersSubscribedToTopicError` exception.
        """
    async def gossipsub_recv(self) -> tuple[builtins.str, bytes]:
        r"""
        Receives the next message from the `GossipSub` network.
        """
    async def gossipsub_recv_many(self, limit: builtins.int) -> builtins.list[tuple[builtins.str, bytes]]:
        r"""
        Receives at most `limit` messages from the `GossipSub` network and returns them.
        
        For `limit = 0`, an empty collection of messages will be returned immediately.
        For `limit > 0`, if there are no messages in the channel's queue this method
        will sleep until a message is sent.
        """

@typing.final
class MessageTooLargeError(builtins.Exception):
    def __new__(cls, *args: typing.Any) -> MessageTooLargeError: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class NoPeersSubscribedToTopicError(builtins.Exception):
    def __new__(cls, *args: typing.Any) -> NoPeersSubscribedToTopicError: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class ConnectionUpdateType(enum.Enum):
    r"""
    Connection or disconnection event discriminant type.
    """
    Connected = ...
    Disconnected = ...

